
#include <stdlib.h>
#include <stdint.h>
#include <assert.h>
#include <strings.h>

#include <arpa/inet.h>

#include "imgio.h"

void free_image(Image *image) {

  free(image->buf);
  free(image->jpeg_buf);
  free(image->yuv_buf);
  free(image);
  if (image->ctx) cairo_destroy(image->ctx);
  if (image->surf) cairo_surface_destroy(image->surf);

}

Image *read_jpeg_frame(TJContext *ctx, FILE *fin) {

  Image *image = (Image*) malloc(sizeof(Image));
  bzero(image, sizeof(Image));

  uint32_t length;
  double timestamp;
  size_t res;
  res = fread(&timestamp, 8, 1, fin);
  assert(res == 1);
  res = fread(&length, 4, 1, fin);
  assert(res == 1);
  length = ntohl(length);
  //fprintf(stderr, "read length: %d\n", length);
  image->jpeg_buf = (unsigned char*) malloc(length);
  res = fread(image->jpeg_buf, 1, length, fin);
  assert(res == length);

  image->jpeg_length = length;
  image->timestamp = timestamp;

  return image;

}

Image *read_frame(TJContext *ctx, FILE *fin) {

  Image *image = read_jpeg_frame(ctx, fin);

  DecodeRes dres = decode_image(ctx, image->jpeg_buf, image->jpeg_length, TJPF_BGRX, TJFLAG_ACCURATEDCT);
  image->width = dres.width;
  image->height = dres.height;
  image->buf = dres.buf;
  image->subsamp = dres.subsamp;

  // We clear away JPEG buffer in order to reclaim memory and avoid
  // confusion
  free(image->jpeg_buf);
  image->jpeg_buf = NULL;

  return image;

}

Image *read_frame_to_yuv(TJContext *ctx, FILE *fin) {

  Image *image = read_jpeg_frame(ctx, fin);

  DecodeYUVRes dres = decode_image_to_yuv(ctx, image->jpeg_buf, image->jpeg_length, TJFLAG_ACCURATEDCT);
  image->width = dres.width;
  image->height = dres.height;
  image->yuv_buf = dres.buf;
  image->yuv_len = dres.len;
  image->subsamp = dres.subsamp;

  // We clear away JPEG buffer in order to reclaim memory and avoid
  // confusion
  free(image->jpeg_buf);
  image->jpeg_buf = NULL;

  return image;

}

void write_jpeg_frame(TJContext *ctx, FILE *fout, Image *image) {

  uint32_t length32 = htonl((uint32_t) image->jpeg_length);
  size_t res;
  res = fwrite(&image->timestamp, 8, 1, fout);
  assert(res == 1);
  res = fwrite(&length32, 4, 1, fout);
  assert(res == 1);
  res = fwrite(image->jpeg_buf, 1, image->jpeg_length, fout);
  assert(res == image->jpeg_length);

}

void write_frame(TJContext *ctx, FILE *fout, Image *image) {

  EncodeRes eres = encode_image(ctx, (unsigned long) image->buf, image->width, image->height, TJPF_BGRX, TJSAMP_444, 95, TJFLAG_ACCURATEDCT);

  image->jpeg_length = eres.len;
  image->jpeg_buf = eres.buf;

  write_jpeg_frame(ctx, fout, image);

  // We clear away JPEG buffer in order to reclaim memory and avoid
  // confusion
  free_encoded_image(image->jpeg_buf);
  image->jpeg_buf = NULL;

}

void get_cairo_context(Image *image) {

  image->surf = cairo_image_surface_create_for_data(image->buf, CAIRO_FORMAT_RGB24, image->width, image->height, 4 * image->width);
  image->ctx = cairo_create(image->surf);

}

// Convert YUV images from the format generated by TurboJPEG (see
// documentation for tjEncodeYUV2()) to the one understood by SDL
// (planes fully unpacked and with specified stride, which is called
// pitch)
void copy_yuv_to_planes(Image *image, Uint16 *pitches, Uint8 **pixels, int swap_chroma) {

  // Detect which kind of subsampling we have
  int hsub = (image->subsamp == TJSAMP_420 || image->subsamp == TJSAMP_422);
  int vsub = (image->subsamp == TJSAMP_420 || image->subsamp == TJSAMP_440);

  // Luma dimensions are padded to 2 on subsampled directions; then
  // width is padded to 4 (???: but then what is the point of perhaps
  // padding to 2 before?)
  int luma_width = image->width;
  int luma_height = image->height;
  if (hsub) {
    luma_width = (luma_width + 1) & -2;
  }
  if (vsub) {
    luma_height = (luma_height + 1) & -2;
  }
  luma_width = (luma_width + 3) & -4;

  // Chroma dimensions are just computed according to subsampling;
  // moreover, width is padded to 4
  int chroma_width = image->width;
  int chroma_height = image->height;
  if (hsub) {
    chroma_width = (chroma_width + 1) / 2;
  }
  if (vsub) {
    chroma_height = (chroma_height + 1) / 2;
  }
  int actual_chroma_width = chroma_width;
  chroma_width = (chroma_width + 3) & -4;
  int target_chroma_width = (image->width + 1) / 2;
  int target_chroma_height = (image->height + 1) / 2;

  // Copy luma plane
  unsigned char *base = image->yuv_buf;
  int i;
  for (i = 0; i < image->height; i++) {
    memcpy(&pixels[0][i * pitches[0]], base, image->width);
    base += luma_width;
  }

  // If the original image is already subsampled on both directions,
  // we can copy stuff around directly
  if (hsub && vsub) {
    // Copy first chroma plane
    base = image->yuv_buf + luma_width * luma_height;
    for (i = 0; i < chroma_height; i++) {
      memcpy(&pixels[swap_chroma ? 2 : 1][i * pitches[swap_chroma ? 2 : 1]], base, actual_chroma_width);
      base += chroma_width;
    }

    // Copy second chroma plane
    base = image->yuv_buf + luma_width * luma_height + chroma_width * chroma_height;
    for (i = 0; i < chroma_height; i++) {
      memcpy(&pixels[swap_chroma ? 1 : 2][i * pitches[swap_chroma ? 1 : 2]], base, actual_chroma_width);
      base += chroma_width;
    }
  }

  // If not, we have to implement rescaling by hand (FIXME: although
  // we should better call an accelerated function from some libav
  // library; FIXME: duplicated code; FIXME: some cases are not
  // supported)
  else {
    // Copy first chroma plane
    if (image->width % 2 == 1 || image->height % 2 == 1) {
      fprintf(stderr, "Images with odd size are not supported\n");
      exit(1);
    }
    base = image->yuv_buf + luma_width * luma_height;
    int j;
    for (i = 0; i < target_chroma_height; i++) {
      for (j = 0; j < target_chroma_width; j++) {
        if (!hsub && !vsub) {
          pixels[swap_chroma ? 2 : 1][i * pitches[swap_chroma ? 2 : 1] + j] =
            (base[chroma_width * 2 * i + 2 * j] +
             base[chroma_width * 2 * i + 2 * j + 1] +
             base[chroma_width * (2 * i + 1) + 2 * j] +
             base[chroma_width * (2 * i + 1) + 2 * j + 1]) / 4;
        } else {
          fprintf(stderr, "Only 444 and 420 subsampling are supported\n");
          exit(1);
        }
      }
    }

    // Copy second chroma plane
    base = image->yuv_buf + luma_width * luma_height + chroma_width * chroma_height;
    for (i = 0; i < target_chroma_height; i++) {
      for (j = 0; j < target_chroma_width; j++) {
        if (!hsub && !vsub) {
          pixels[swap_chroma ? 1 : 2][i * pitches[swap_chroma ? 1 : 2] + j] =
            (base[chroma_width * 2 * i + 2 * j] +
             base[chroma_width * 2 * i + 2 * j + 1] +
             base[chroma_width * (2 * i + 1) + 2 * j] +
             base[chroma_width * (2 * i + 1) + 2 * j + 1]) / 4;
        } else {
          fprintf(stderr, "Only 444 and 420 subsampling are supported\n");
          exit(1);
        }
      }
    }
  }

  // Whoo, we really hope everything went fine... Specs are definitely
  // not clear!

}
